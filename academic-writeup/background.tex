\section{Background}
\label{SEC:background}

We briefly review the relevant properties of cryptographic $(k, n)$-threshold
schemes.  Although the specific $(k,n)$-threshold scheme that is used 
is not fundamental to our
work, we describe Shamir Secret Sharing \cite{shamir1979share}, which we use to develop
explicit examples within the text. 

\emph{The $(k, n)$-threshold scheme}

Threshold schemes protect secret information (usually a key) by deriving $n$
different shares from this information.  A threshold scheme describes how any $k$
shares (from a set of n total shares) can be used to recover an original
secret.  The number of needed shares, $k$, is called the threshold.  If fewer than
$k$ shares are known, no information about the secret is provided.

Shamir Secret Sharing is an algorithm that describes how a secret is divided
into a set of $n$ shares.  If a threshold $k$ of shares are input (specified when the 
secret is divided), the original secret can be reconstructed. To hide
a secret, Shamir Secret Sharing computes $k - 1$ random coefficients for a $k - 1$
degree polynomial $f(x)$ in a finite field (commonly GF-256 or GF-65536). The $k$th
term (commonly the constant term) contains the secret. To compute a share, a
value between 1 and the order of the field is chosen. The polynomial is
evaluated with $x$ equal to the share value, where the terms $x$ and $f(x)$ are used
as the share. To reconstruct the secret from at least $k$ shares, a party can
interpolate the values in the finite field to find the constant term (i.e., the
secret). In practice, interpolation is often computationally optimized so that
only the constant term is recovered.

Suppose that a secret, 235, is to be hidden so that it can only be
reconstructed if three shares are provided. Because the threshold is three, two
random terms are first generated (24 and 182) to build a GF-256 polynomial,
such as $f(x) = 24x^2 + 182x + 235$. Shares can then be generated by computing $x$
and $f(x)$, such as: (1, 92), (2, 148), (3, 37), (4, 69), etc. A party that has
at least three shares can interpolate to reconstruct the full polynomial of
$f(x)$ and thus, the secret (235). 

It is possible to generate additional shares after recovering the secret, (e.g.,
if Lagrange interpolation is performed during reconstruction). This makes share
recovery slightly more computationally complex but also makes it possible (and
efficient) to generate additional shares simply by evaluating f(x) for the
specified share.  This means that all shares do not need to be created
initially --- they may instead be added (or recovered) after the secret has
been reconstructed.

In many cases, the secret will be larger than the size of the finite field.  A
large secret can be stored by breaking it into segments that are the size of
the finite field (often one or two bytes) and applying the above technique
separately to each segment.  The same share number, $x$, is typically used for
each share $f_i(x)$.  This simplifies --- and effectively hides --- the fact that a
secret has only a limited size.  An integrity check can be added to detect whether
an incorrect share has been provided.  As was previously described, when given a set
of any k distinct shares, whether valid or invalid, Shamir Secret Sharing will
produce a polynomial of the appropriate length. This means that if any share is
invalid, its resulting polynomial will be incorrect. To avoid this problem,
implementations of Shamir Secret Sharing typically store an integrity check by
appending the hash of the secret to the secret; this check detects if an
incorrect share has been provided.  When the shares are reconstructed, the
additional integrity check provides verification that the correct shares were
given.

